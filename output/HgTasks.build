<project>
  <script language="c#">
    <references>
      <include name="System.dll" />
    </references>
    <imports>
      <import namespace="System.Diagnostics" />
    </imports>
    <code><![CDATA[

    /// <summary>
    /// A task to run hg verify
    /// 
    /// You can optionally delete the repository if an error is encountered.
    /// I use this on our continuous integration server where occasionally the
    /// repo becomes corrupted - then I can easily re-clone the repo before continuing.
    /// </summary>
    [TaskName("hg_clone")]
    public class Clone : Task
    {
        private DirectoryInfo repository;
        /// <summary>
        /// Path to local repo
        /// </summary>
        [TaskAttribute("repo", Required = true)]
        public DirectoryInfo Repository
        {
            get { return repository; }
            set { repository = value; }
        }

        private string source = string.Empty;
        /// <summary>
        /// Url to Source repo
        /// Uses default as set in hgrc by default
        /// </summary>
        [TaskAttribute("source", Required = false)]
        public string Source
        {
            get { return source; }
            set { source = value; }
        }

        private bool removeIfExists = false;
        /// <summary>
        /// Do you want to remove the repo if it exists in order to have a fresh clone?
        /// </summary>
        [TaskAttribute("removeIfExists", Required = false)]
        public bool RemoveIfExists
        {
            get { return removeIfExists; }
            set { removeIfExists = value; }
        }

        private string Command
        {
            get
            {
                return string.Format("clone {0} {1}", Source, Repository.Name);
            }
        }

        protected override void ExecuteTask()
        {
            if (HgDefaults.IsRepo(Repository))
            {
                Log(Level.Debug, "Repository found.");

                if (RemoveIfExists)
                {
                    Log(Level.Info, "Deleting for re-clone.");
                    Repository.Delete(true);
                }
                else
                {
                    // repo exists - clone is not necessary
                    return;
                }
            }

            Log(Level.Info, "Cloning {0}...", Repository.Name);

            HgProcess process = HgProcess.Run(Command, Repository.Parent.FullName, FailOnError);

            if (Verbose)
                Log(Level.Debug, process.StandardOutput);
            
            Log(Level.Info, "Completed.");
        }
    }



    [TaskName("hg_get_tag")]
    public class GetTag : Task
    {
        private DirectoryInfo repository;
        /// <summary>
        /// Full path to the repository
        /// </summary>
        [TaskAttribute("repo", Required = true)]
        public DirectoryInfo Repository
        {
            get { return repository; }
            set { repository = value; }
        }

        private string Command
        {
            get
            {
                return "log -r tip";
            }
        }

        protected override void ExecuteTask()
        {
            if (!HgDefaults.IsRepo(Repository))
            {
                Error("Repository not found.");
                return;
            }

            Log(Level.Info, "Running hg log on {0}.", Repository.Name);

            HgProcess process = HgProcess.Run(Command, Repository.FullName, FailOnError);

            string tag = "";
            string[] lines = process.StandardOutput.Split('\n');

            foreach (string line in lines)
            {
                if (line.Contains("changeset:"))
                {
                    string[] chunks = line.Split(':');
                    tag = chunks[2];
                }
            }

            Project.Properties["HgTag"] = tag;

            Log(Level.Debug, "Set HgTag property to {0}.", tag);
            Log(Level.Info, "Completed.");
        }

        protected void Error(string message, params object[] args)
        {
            string err = string.Format(message, args);

            if (FailOnError)
                throw new Exception(err);

            Log(Level.Error, err);
        }
    }


    internal class HgDefaults
    {
        public const string Branch = "default";

        public static bool IsRepo(DirectoryInfo dir)
        {
            return Directory.Exists(Path.Combine(dir.FullName, ".hg"));
        }
    }


    /// <summary>
    /// A really simple helper class to handle running the process
    /// </summary>
    internal class HgProcess
    {
        private static readonly log4net.ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

        public string StandardOutput { get; private set; }
        public string StandardError { get; private set; }
        public int ExitCode { get; private set; }

        public static HgProcess Run(string arguments, string workingDirectory, bool failOnError)
        {
            log.DebugFormat("Running in {0}.{1}Command: hg {2}", workingDirectory, Environment.NewLine, arguments);

            HgProcess process = new HgProcess();

            Process p = new Process();
            p.StartInfo.FileName = "hg";
            p.StartInfo.Arguments = arguments;
            p.StartInfo.WorkingDirectory = workingDirectory;
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = true;

            using (p)
            {
                p.Start();
                process.StandardOutput = p.StandardOutput.ReadToEnd();
                process.StandardError = p.StandardError.ReadToEnd();
                p.WaitForExit();
                process.ExitCode = p.ExitCode;
            }

            if (!string.IsNullOrEmpty(process.StandardError))
            {
                string error = string.Format("Error during hg command: {0}{1}Errors:{2}", arguments, Environment.NewLine, process.StandardError);

                if (failOnError)
                    throw new Exception(error);

                log.Error(error);
            }

            return process;
        }
    }



    /// <summary>
    /// A task to run a set of hg tasks that prepare a repo for use
    /// </summary>
    [TaskName("hg_prepare")]
    public class Prepare : Task
    {
        private DirectoryInfo repository;
        /// <summary>
        /// Path to local repo
        /// </summary>
        [TaskAttribute("repo", Required = true)]
        public DirectoryInfo Repository
        {
            get { return repository; }
            set { repository = value; }
        }

        private string source = string.Empty;
        /// <summary>
        /// Url to Source repo
        /// Uses default as set in hgrc by default
        /// </summary>
        [TaskAttribute("source", Required = false)]
        public string Source
        {
            get { return source; }
            set { source = value; }
        }

        private string branch = HgDefaults.Branch;
        /// <summary>
        /// Branch to update to
        /// </summary>
        [TaskAttribute("branch", Required = false)]
        public string Branch
        {
            get { return branch; }
            set { branch = value; }
        }

        private string rev;
        /// <summary>
        /// Changeset or Tag to update to
        /// </summary>
        [TaskAttribute("rev", Required = false)]
        public string Rev
        {
            get { return rev; }
            set { rev = value; }
        }

        private bool clean = true;
        /// <summary>
        /// Clean repo on update?
        /// Defaults to true
        /// </summary>
        [TaskAttribute("clean", Required = false)]
        public bool Clean
        {
            get { return clean; }
            set { clean = value; }
        }

        private bool deleteIfUnverified = true;
        /// <summary>
        /// Do you want to delete the repo if there is an error
        /// </summary>
        [TaskAttribute("deleteIfUnverified", Required = false)]
        public bool DeleteIfUnverified
        {
            get { return deleteIfUnverified; }
            set { deleteIfUnverified = value; }
        }

        protected override void ExecuteTask()
        {
            // verify the repo first
            // checking for a pending transaction or corruption
            Verify verify = new Verify()
            {
                DeleteIfUnverified = this.DeleteIfUnverified,
                Repository = this.Repository,
                FailOnError = this.FailOnError,
                Verbose = this.Verbose
            };
            verify.Execute();

            // now clone if needed
            if (!HgDefaults.IsRepo(Repository))
            {
                Clone clone = new Clone()
                {
                    Repository = this.Repository,
                    FailOnError = this.FailOnError,
                    Source = this.Source,
                    Verbose = this.Verbose
                };
                clone.Execute();
            }
            // repo exists so lets pull the latest
            else
            {
                Pull pull = new Pull()
                {
                    Repository = this.Repository,
                    FailOnError = this.FailOnError,
                    Source = this.Source,
                    Verbose = this.Verbose
                };
                pull.Execute();
            }

            // update to the correct branch and rev/tag
            Update update = new Update()
            {
                Repository = this.Repository,
                FailOnError = this.FailOnError,
                Clean = this.Clean,
                Branch = this.Branch,
                Rev = this.Rev,
                Verbose = this.Verbose
            };
            update.Execute();
        }
    }



    /// <summary>
    /// Perform an hg pull set source repo or use 
    /// </summary>
    [TaskName("hg_pull")]
    public class Pull : Task
    {
        private DirectoryInfo repository;
        /// <summary>
        /// Path to local repo
        /// </summary>
        [TaskAttribute("repo", Required = true)]
        public DirectoryInfo Repository
        {
            get { return repository; }
            set { repository = value; }
        }

        private string source = string.Empty;
        /// <summary>
        /// Url to Source repo
        /// Uses default as set in hgrc by default
        /// </summary>
        [TaskAttribute("source", Required = false)]
        public string Source
        {
            get { return source; }
            set { source = value; }
        }

        private bool withUpdate = false;
        /// <summary>
        /// Update to tip after pull
        /// </summary>
        [TaskAttribute("update", Required = false)]
        public bool WithUpdate
        {
            get { return withUpdate; }
            set { withUpdate = value; }
        }

        private string Command
        {
            get
            {
                return string.Format("pull {1} {2}", Source, (WithUpdate ? "--update" : ""));
            }
        }

        protected override void ExecuteTask()
        {
            if (!HgDefaults.IsRepo(Repository))
            {
                Log(Level.Error, "Repository not found.");
                return;
            }

            Log(Level.Info, "Pulling latest for {0}...", Repository.Name);
            HgProcess process = HgProcess.Run(Command, Repository.FullName, FailOnError);

            if (WithUpdate && process.StandardOutput.Contains("no changes found"))
                Log(Level.Info, "No changes found, update not done.");

            if (Verbose)
                Log(Level.Debug, process.StandardOutput);
        }
    }



    /// <summary>
    /// A task to run hg update
    /// 
    /// Can update to a target branch and rev if the required params are set
    /// Updates to the default branch by default
    /// </summary>
    [TaskName("hg_update")]
    public class Update : Task
    {
        private DirectoryInfo repository;
        /// <summary>
        /// Path to local repo
        /// </summary>
        [TaskAttribute("repo", Required = true)]
        public DirectoryInfo Repository
        {
            get { return repository; }
            set { repository = value; }
        }

        private string source = string.Empty;
        /// <summary>
        /// Url to Source repo
        /// Uses default as set in hgrc by default
        /// </summary>
        [TaskAttribute("source", Required = false)]
        public string Source
        {
            get { return source; }
            set { source = value; }
        }

        private string branch = HgDefaults.Branch;
        /// <summary>
        /// Branch to update to
        /// </summary>
        [TaskAttribute("branch", Required = false)]
        public string Branch
        {
            get { return branch; }
            set { branch = value; }
        }

        private string rev;
        /// <summary>
        /// Changeset or Tag to update to
        /// </summary>
        [TaskAttribute("rev", Required = false)]
        public string Rev
        {
            get { return rev; }
            set { rev = value; }
        }

        private bool clean = true;
        /// <summary>
        /// Clean repo on update?
        /// Defaults to true
        /// </summary>
        [TaskAttribute("clean", Required = false)]
        public bool Clean
        {
            get { return clean; }
            set { clean = value; }
        }

        private string ToBranchCommand
        {
            get
            {
                return string.Format("update {0} {1}", (Clean ? "--clean" : ""), Branch);
            }
        }

        private string ToRevCommand
        {
            get
            {
                return string.Format("update {0} --rev {1}", (Clean ? "--clean" : ""), Rev);
            }
        }

        protected override void ExecuteTask()
        {
            if (!HgDefaults.IsRepo(Repository))
            {
                Error("Repository not found.");
                return;
            }

            // update to tip of selected branch
            Log(Level.Info, "Updating to branch {0}.", Branch);
            HgProcess process = HgProcess.Run(ToBranchCommand, Repository.FullName, FailOnError);

            if (!string.IsNullOrEmpty(Rev))
            {
                Log(Level.Info, "Updating to Rev {0}.", Rev);
                process = HgProcess.Run(ToRevCommand, Repository.FullName, FailOnError);
            }

            if (Verbose)
                Log(Level.Debug, process.StandardOutput);

            Log(Level.Info, "Completed.");
        }

        protected void Error(string message, params object[] args)
        {
            string err = string.Format(message, args);

            if (FailOnError)
                throw new Exception(err);

            Log(Level.Error, err);
        }
    }



    /// <summary>
    /// A task to run hg verify
    /// 
    /// You can optionally delete the repository if an error is encountered.
    /// I use this on our continuous integration server where occasionally the
    /// repo becomes corrupted - then I can easily re-clone the repo before continuing.
    /// </summary>
    [TaskName("hg_verify")]
    public class Verify : Task
    {
        private DirectoryInfo repository;
        /// <summary>
        /// Full path to the repository
        /// </summary>
        [TaskAttribute("repo", Required = true)]
        public DirectoryInfo Repository
        {
            get { return repository; }
            set { repository = value; }
        }

        private bool deleteIfUnverified = true;
        /// <summary>
        /// Do you want to delete the repo if there is an error
        /// </summary>
        [TaskAttribute("deleteIfUnverified", Required = false)]
        public bool DeleteIfUnverified
        {
            get { return deleteIfUnverified; }
            set { deleteIfUnverified = value; }
        }

        protected override void ExecuteTask()
        {
            if (!HgDefaults.IsRepo(Repository))
            {
                Log(Level.Info, "Repository not found.");
                return;
            }

            Log(Level.Info, "Running hg verify on {0}.", Repository.Name);

            HgProcess process = HgProcess.Run("verify", Repository.FullName, false);

            if (!string.IsNullOrEmpty(process.StandardError))
            {
                Log(Level.Error, "Repository was not verified. Errors:{0}{1}", Environment.NewLine, process.StandardError);

                if (DeleteIfUnverified)
                {
                    Log(Level.Info, "Deleting repository...");
                    Repository.Delete(true);
                }
            }
            else
            {
                Log(Level.Info, "No errors found.");
            }

            Log(Level.Info, "Completed.");
        }
    }

]]></code>
  </script>
</project>